# -*- coding: utf-8 -*-
# code generated by Prisma. DO NOT EDIT.
# pyright: reportUnusedImport=false
# fmt: off

# global imports for type checking
from builtins import bool as _bool
from builtins import int as _int
from builtins import float as _float
from builtins import str as _str
import sys
import decimal
import datetime
from typing import (
    TYPE_CHECKING,
    Optional,
    Iterable,
    Iterator,
    Sequence,
    Callable,
    ClassVar,
    NoReturn,
    TypeVar,
    Generic,
    Mapping,
    Tuple,
    Union,
    List,
    Dict,
    Type,
    Any,
    Set,
    overload,
    cast,
)
from typing_extensions import TypedDict, Literal


LiteralString = str
# -- template models.py.jinja --
import os
import logging
import inspect
import warnings
from collections import OrderedDict

from pydantic import BaseModel, Field

from . import types, enums, errors, fields, bases
from ._types import FuncType
from ._compat import model_rebuild, field_validator
from ._builder import serialize_base64
from .generator import partial_models_ctx, PartialModelField


log: logging.Logger = logging.getLogger(__name__)
_created_partial_types: Set[str] = set()

class User(bases.BaseUser):
    """Represents a User record"""

    user_id: _int
    username: _str
    email: _str
    password_hash: _str
    total_coins: _int
    streak_count: _int
    last_active_date: Optional[datetime.datetime] = None
    todos: Optional[List['models.Todo']] = None
    Todo_categories: Optional[List['models.TodoCategory']] = None
    coin_transactions: Optional[List['models.CoinTransaction']] = None
    reward_redemptions: Optional[List['models.RewardRedemption']] = None
    user_achievements: Optional[List['models.UserAchievement']] = None

    # take *args and **kwargs so that other metaclasses can define arguments
    def __init_subclass__(
        cls,
        *args: Any,
        warn_subclass: Optional[bool] = None,
        **kwargs: Any,
    ) -> None:
        super().__init_subclass__()
        if warn_subclass is not None:
            warnings.warn(
                'The `warn_subclass` argument is deprecated as it is no longer necessary and will be removed in the next release',
                DeprecationWarning,
                stacklevel=3,
            )


    @staticmethod
    def create_partial(
        name: str,
        include: Optional[Iterable['types.UserKeys']] = None,
        exclude: Optional[Iterable['types.UserKeys']] = None,
        required: Optional[Iterable['types.UserKeys']] = None,
        optional: Optional[Iterable['types.UserKeys']] = None,
        relations: Optional[Mapping['types.UserRelationalFieldKeys', str]] = None,
        exclude_relational_fields: bool = False,
    ) -> None:
        if not os.environ.get('PRISMA_GENERATOR_INVOCATION'):
            raise RuntimeError(
                'Attempted to create a partial type outside of client generation.'
            )

        if name in _created_partial_types:
            raise ValueError(f'Partial type "{name}" has already been created.')

        if include is not None:
            if exclude is not None:
                raise TypeError('Exclude and include are mutually exclusive.')
            if exclude_relational_fields is True:
                raise TypeError('Include and exclude_relational_fields=True are mutually exclusive.')

        if required and optional:
            shared = set(required) & set(optional)
            if shared:
                raise ValueError(f'Cannot make the same field(s) required and optional {shared}')

        if exclude_relational_fields and relations:
            raise ValueError(
                'exclude_relational_fields and relations are mutually exclusive'
            )

        fields: Dict['types.UserKeys', PartialModelField] = OrderedDict()

        try:
            if include:
                for field in include:
                    fields[field] = _User_fields[field].copy()
            elif exclude:
                for field in exclude:
                    if field not in _User_fields:
                        raise KeyError(field)

                fields = {
                    key: data.copy()
                    for key, data in _User_fields.items()
                    if key not in exclude
                }
            else:
                fields = {
                    key: data.copy()
                    for key, data in _User_fields.items()
                }

            if required:
                for field in required:
                    fields[field]['optional'] = False

            if optional:
                for field in optional:
                    fields[field]['optional'] = True

            if exclude_relational_fields:
                fields = {
                    key: data
                    for key, data in fields.items()
                    if key not in _User_relational_fields
                }

            if relations:
                for field, type_ in relations.items():
                    if field not in _User_relational_fields:
                        raise errors.UnknownRelationalFieldError('User', field)

                    # TODO: this method of validating types is not ideal
                    # as it means we cannot two create partial types that
                    # reference each other
                    if type_ not in _created_partial_types:
                        raise ValueError(
                            f'Unknown partial type: "{type_}". '
                            f'Did you remember to generate the {type_} type before this one?'
                        )

                    # TODO: support non prisma.partials models
                    info = fields[field]
                    if info['is_list']:
                        info['type'] = f'List[\'partials.{type_}\']'
                    else:
                        info['type'] = f'\'partials.{type_}\''
        except KeyError as exc:
            raise ValueError(
                f'{exc.args[0]} is not a valid User / {name} field.'
            ) from None

        models = partial_models_ctx.get()
        models.append(
            {
                'name': name,
                'fields': cast(Mapping[str, PartialModelField], fields),
                'from_model': 'User',
            }
        )
        _created_partial_types.add(name)


class TodoCategory(bases.BaseTodoCategory):
    """Represents a TodoCategory record"""

    category_id: _int
    category_name: _str
    difficulty_multiplier: _float
    todos: Optional[List['models.Todo']] = None
    user: Optional['models.User'] = None
    user_id: _int

    # take *args and **kwargs so that other metaclasses can define arguments
    def __init_subclass__(
        cls,
        *args: Any,
        warn_subclass: Optional[bool] = None,
        **kwargs: Any,
    ) -> None:
        super().__init_subclass__()
        if warn_subclass is not None:
            warnings.warn(
                'The `warn_subclass` argument is deprecated as it is no longer necessary and will be removed in the next release',
                DeprecationWarning,
                stacklevel=3,
            )


    @staticmethod
    def create_partial(
        name: str,
        include: Optional[Iterable['types.TodoCategoryKeys']] = None,
        exclude: Optional[Iterable['types.TodoCategoryKeys']] = None,
        required: Optional[Iterable['types.TodoCategoryKeys']] = None,
        optional: Optional[Iterable['types.TodoCategoryKeys']] = None,
        relations: Optional[Mapping['types.TodoCategoryRelationalFieldKeys', str]] = None,
        exclude_relational_fields: bool = False,
    ) -> None:
        if not os.environ.get('PRISMA_GENERATOR_INVOCATION'):
            raise RuntimeError(
                'Attempted to create a partial type outside of client generation.'
            )

        if name in _created_partial_types:
            raise ValueError(f'Partial type "{name}" has already been created.')

        if include is not None:
            if exclude is not None:
                raise TypeError('Exclude and include are mutually exclusive.')
            if exclude_relational_fields is True:
                raise TypeError('Include and exclude_relational_fields=True are mutually exclusive.')

        if required and optional:
            shared = set(required) & set(optional)
            if shared:
                raise ValueError(f'Cannot make the same field(s) required and optional {shared}')

        if exclude_relational_fields and relations:
            raise ValueError(
                'exclude_relational_fields and relations are mutually exclusive'
            )

        fields: Dict['types.TodoCategoryKeys', PartialModelField] = OrderedDict()

        try:
            if include:
                for field in include:
                    fields[field] = _TodoCategory_fields[field].copy()
            elif exclude:
                for field in exclude:
                    if field not in _TodoCategory_fields:
                        raise KeyError(field)

                fields = {
                    key: data.copy()
                    for key, data in _TodoCategory_fields.items()
                    if key not in exclude
                }
            else:
                fields = {
                    key: data.copy()
                    for key, data in _TodoCategory_fields.items()
                }

            if required:
                for field in required:
                    fields[field]['optional'] = False

            if optional:
                for field in optional:
                    fields[field]['optional'] = True

            if exclude_relational_fields:
                fields = {
                    key: data
                    for key, data in fields.items()
                    if key not in _TodoCategory_relational_fields
                }

            if relations:
                for field, type_ in relations.items():
                    if field not in _TodoCategory_relational_fields:
                        raise errors.UnknownRelationalFieldError('TodoCategory', field)

                    # TODO: this method of validating types is not ideal
                    # as it means we cannot two create partial types that
                    # reference each other
                    if type_ not in _created_partial_types:
                        raise ValueError(
                            f'Unknown partial type: "{type_}". '
                            f'Did you remember to generate the {type_} type before this one?'
                        )

                    # TODO: support non prisma.partials models
                    info = fields[field]
                    if info['is_list']:
                        info['type'] = f'List[\'partials.{type_}\']'
                    else:
                        info['type'] = f'\'partials.{type_}\''
        except KeyError as exc:
            raise ValueError(
                f'{exc.args[0]} is not a valid TodoCategory / {name} field.'
            ) from None

        models = partial_models_ctx.get()
        models.append(
            {
                'name': name,
                'fields': cast(Mapping[str, PartialModelField], fields),
                'from_model': 'TodoCategory',
            }
        )
        _created_partial_types.add(name)


class Todo(bases.BaseTodo):
    """Represents a Todo record"""

    todo_id: _int
    user: Optional['models.User'] = None
    user_id: _int
    title: _str
    description: Optional[_str] = None
    due_date: Optional[datetime.datetime] = None
    base_coin_value: _int
    completed: _bool
    completion_date: Optional[datetime.datetime] = None
    category: Optional['models.TodoCategory'] = None
    category_id: Optional[_int] = None
    coin_transactions: Optional[List['models.CoinTransaction']] = None

    # take *args and **kwargs so that other metaclasses can define arguments
    def __init_subclass__(
        cls,
        *args: Any,
        warn_subclass: Optional[bool] = None,
        **kwargs: Any,
    ) -> None:
        super().__init_subclass__()
        if warn_subclass is not None:
            warnings.warn(
                'The `warn_subclass` argument is deprecated as it is no longer necessary and will be removed in the next release',
                DeprecationWarning,
                stacklevel=3,
            )


    @staticmethod
    def create_partial(
        name: str,
        include: Optional[Iterable['types.TodoKeys']] = None,
        exclude: Optional[Iterable['types.TodoKeys']] = None,
        required: Optional[Iterable['types.TodoKeys']] = None,
        optional: Optional[Iterable['types.TodoKeys']] = None,
        relations: Optional[Mapping['types.TodoRelationalFieldKeys', str]] = None,
        exclude_relational_fields: bool = False,
    ) -> None:
        if not os.environ.get('PRISMA_GENERATOR_INVOCATION'):
            raise RuntimeError(
                'Attempted to create a partial type outside of client generation.'
            )

        if name in _created_partial_types:
            raise ValueError(f'Partial type "{name}" has already been created.')

        if include is not None:
            if exclude is not None:
                raise TypeError('Exclude and include are mutually exclusive.')
            if exclude_relational_fields is True:
                raise TypeError('Include and exclude_relational_fields=True are mutually exclusive.')

        if required and optional:
            shared = set(required) & set(optional)
            if shared:
                raise ValueError(f'Cannot make the same field(s) required and optional {shared}')

        if exclude_relational_fields and relations:
            raise ValueError(
                'exclude_relational_fields and relations are mutually exclusive'
            )

        fields: Dict['types.TodoKeys', PartialModelField] = OrderedDict()

        try:
            if include:
                for field in include:
                    fields[field] = _Todo_fields[field].copy()
            elif exclude:
                for field in exclude:
                    if field not in _Todo_fields:
                        raise KeyError(field)

                fields = {
                    key: data.copy()
                    for key, data in _Todo_fields.items()
                    if key not in exclude
                }
            else:
                fields = {
                    key: data.copy()
                    for key, data in _Todo_fields.items()
                }

            if required:
                for field in required:
                    fields[field]['optional'] = False

            if optional:
                for field in optional:
                    fields[field]['optional'] = True

            if exclude_relational_fields:
                fields = {
                    key: data
                    for key, data in fields.items()
                    if key not in _Todo_relational_fields
                }

            if relations:
                for field, type_ in relations.items():
                    if field not in _Todo_relational_fields:
                        raise errors.UnknownRelationalFieldError('Todo', field)

                    # TODO: this method of validating types is not ideal
                    # as it means we cannot two create partial types that
                    # reference each other
                    if type_ not in _created_partial_types:
                        raise ValueError(
                            f'Unknown partial type: "{type_}". '
                            f'Did you remember to generate the {type_} type before this one?'
                        )

                    # TODO: support non prisma.partials models
                    info = fields[field]
                    if info['is_list']:
                        info['type'] = f'List[\'partials.{type_}\']'
                    else:
                        info['type'] = f'\'partials.{type_}\''
        except KeyError as exc:
            raise ValueError(
                f'{exc.args[0]} is not a valid Todo / {name} field.'
            ) from None

        models = partial_models_ctx.get()
        models.append(
            {
                'name': name,
                'fields': cast(Mapping[str, PartialModelField], fields),
                'from_model': 'Todo',
            }
        )
        _created_partial_types.add(name)


class CoinTransaction(bases.BaseCoinTransaction):
    """Represents a CoinTransaction record"""

    transaction_id: _int
    user: Optional['models.User'] = None
    user_id: _int
    amount: _int
    transaction_type: 'enums.TransactionType'
    transaction_time: datetime.datetime
    related_todo: Optional['models.Todo'] = None
    related_todo_id: Optional[_int] = None

    # take *args and **kwargs so that other metaclasses can define arguments
    def __init_subclass__(
        cls,
        *args: Any,
        warn_subclass: Optional[bool] = None,
        **kwargs: Any,
    ) -> None:
        super().__init_subclass__()
        if warn_subclass is not None:
            warnings.warn(
                'The `warn_subclass` argument is deprecated as it is no longer necessary and will be removed in the next release',
                DeprecationWarning,
                stacklevel=3,
            )


    @staticmethod
    def create_partial(
        name: str,
        include: Optional[Iterable['types.CoinTransactionKeys']] = None,
        exclude: Optional[Iterable['types.CoinTransactionKeys']] = None,
        required: Optional[Iterable['types.CoinTransactionKeys']] = None,
        optional: Optional[Iterable['types.CoinTransactionKeys']] = None,
        relations: Optional[Mapping['types.CoinTransactionRelationalFieldKeys', str]] = None,
        exclude_relational_fields: bool = False,
    ) -> None:
        if not os.environ.get('PRISMA_GENERATOR_INVOCATION'):
            raise RuntimeError(
                'Attempted to create a partial type outside of client generation.'
            )

        if name in _created_partial_types:
            raise ValueError(f'Partial type "{name}" has already been created.')

        if include is not None:
            if exclude is not None:
                raise TypeError('Exclude and include are mutually exclusive.')
            if exclude_relational_fields is True:
                raise TypeError('Include and exclude_relational_fields=True are mutually exclusive.')

        if required and optional:
            shared = set(required) & set(optional)
            if shared:
                raise ValueError(f'Cannot make the same field(s) required and optional {shared}')

        if exclude_relational_fields and relations:
            raise ValueError(
                'exclude_relational_fields and relations are mutually exclusive'
            )

        fields: Dict['types.CoinTransactionKeys', PartialModelField] = OrderedDict()

        try:
            if include:
                for field in include:
                    fields[field] = _CoinTransaction_fields[field].copy()
            elif exclude:
                for field in exclude:
                    if field not in _CoinTransaction_fields:
                        raise KeyError(field)

                fields = {
                    key: data.copy()
                    for key, data in _CoinTransaction_fields.items()
                    if key not in exclude
                }
            else:
                fields = {
                    key: data.copy()
                    for key, data in _CoinTransaction_fields.items()
                }

            if required:
                for field in required:
                    fields[field]['optional'] = False

            if optional:
                for field in optional:
                    fields[field]['optional'] = True

            if exclude_relational_fields:
                fields = {
                    key: data
                    for key, data in fields.items()
                    if key not in _CoinTransaction_relational_fields
                }

            if relations:
                for field, type_ in relations.items():
                    if field not in _CoinTransaction_relational_fields:
                        raise errors.UnknownRelationalFieldError('CoinTransaction', field)

                    # TODO: this method of validating types is not ideal
                    # as it means we cannot two create partial types that
                    # reference each other
                    if type_ not in _created_partial_types:
                        raise ValueError(
                            f'Unknown partial type: "{type_}". '
                            f'Did you remember to generate the {type_} type before this one?'
                        )

                    # TODO: support non prisma.partials models
                    info = fields[field]
                    if info['is_list']:
                        info['type'] = f'List[\'partials.{type_}\']'
                    else:
                        info['type'] = f'\'partials.{type_}\''
        except KeyError as exc:
            raise ValueError(
                f'{exc.args[0]} is not a valid CoinTransaction / {name} field.'
            ) from None

        models = partial_models_ctx.get()
        models.append(
            {
                'name': name,
                'fields': cast(Mapping[str, PartialModelField], fields),
                'from_model': 'CoinTransaction',
            }
        )
        _created_partial_types.add(name)


class Reward(bases.BaseReward):
    """Represents a Reward record"""

    reward_id: _int
    reward_name: _str
    description: Optional[_str] = None
    coin_cost: _int
    is_repeatable: _bool
    reward_redemptions: Optional[List['models.RewardRedemption']] = None

    # take *args and **kwargs so that other metaclasses can define arguments
    def __init_subclass__(
        cls,
        *args: Any,
        warn_subclass: Optional[bool] = None,
        **kwargs: Any,
    ) -> None:
        super().__init_subclass__()
        if warn_subclass is not None:
            warnings.warn(
                'The `warn_subclass` argument is deprecated as it is no longer necessary and will be removed in the next release',
                DeprecationWarning,
                stacklevel=3,
            )


    @staticmethod
    def create_partial(
        name: str,
        include: Optional[Iterable['types.RewardKeys']] = None,
        exclude: Optional[Iterable['types.RewardKeys']] = None,
        required: Optional[Iterable['types.RewardKeys']] = None,
        optional: Optional[Iterable['types.RewardKeys']] = None,
        relations: Optional[Mapping['types.RewardRelationalFieldKeys', str]] = None,
        exclude_relational_fields: bool = False,
    ) -> None:
        if not os.environ.get('PRISMA_GENERATOR_INVOCATION'):
            raise RuntimeError(
                'Attempted to create a partial type outside of client generation.'
            )

        if name in _created_partial_types:
            raise ValueError(f'Partial type "{name}" has already been created.')

        if include is not None:
            if exclude is not None:
                raise TypeError('Exclude and include are mutually exclusive.')
            if exclude_relational_fields is True:
                raise TypeError('Include and exclude_relational_fields=True are mutually exclusive.')

        if required and optional:
            shared = set(required) & set(optional)
            if shared:
                raise ValueError(f'Cannot make the same field(s) required and optional {shared}')

        if exclude_relational_fields and relations:
            raise ValueError(
                'exclude_relational_fields and relations are mutually exclusive'
            )

        fields: Dict['types.RewardKeys', PartialModelField] = OrderedDict()

        try:
            if include:
                for field in include:
                    fields[field] = _Reward_fields[field].copy()
            elif exclude:
                for field in exclude:
                    if field not in _Reward_fields:
                        raise KeyError(field)

                fields = {
                    key: data.copy()
                    for key, data in _Reward_fields.items()
                    if key not in exclude
                }
            else:
                fields = {
                    key: data.copy()
                    for key, data in _Reward_fields.items()
                }

            if required:
                for field in required:
                    fields[field]['optional'] = False

            if optional:
                for field in optional:
                    fields[field]['optional'] = True

            if exclude_relational_fields:
                fields = {
                    key: data
                    for key, data in fields.items()
                    if key not in _Reward_relational_fields
                }

            if relations:
                for field, type_ in relations.items():
                    if field not in _Reward_relational_fields:
                        raise errors.UnknownRelationalFieldError('Reward', field)

                    # TODO: this method of validating types is not ideal
                    # as it means we cannot two create partial types that
                    # reference each other
                    if type_ not in _created_partial_types:
                        raise ValueError(
                            f'Unknown partial type: "{type_}". '
                            f'Did you remember to generate the {type_} type before this one?'
                        )

                    # TODO: support non prisma.partials models
                    info = fields[field]
                    if info['is_list']:
                        info['type'] = f'List[\'partials.{type_}\']'
                    else:
                        info['type'] = f'\'partials.{type_}\''
        except KeyError as exc:
            raise ValueError(
                f'{exc.args[0]} is not a valid Reward / {name} field.'
            ) from None

        models = partial_models_ctx.get()
        models.append(
            {
                'name': name,
                'fields': cast(Mapping[str, PartialModelField], fields),
                'from_model': 'Reward',
            }
        )
        _created_partial_types.add(name)


class RewardRedemption(bases.BaseRewardRedemption):
    """Represents a RewardRedemption record"""

    redemption_id: _int
    user: Optional['models.User'] = None
    user_id: _int
    reward: Optional['models.Reward'] = None
    reward_id: _int
    redemption_date: datetime.datetime

    # take *args and **kwargs so that other metaclasses can define arguments
    def __init_subclass__(
        cls,
        *args: Any,
        warn_subclass: Optional[bool] = None,
        **kwargs: Any,
    ) -> None:
        super().__init_subclass__()
        if warn_subclass is not None:
            warnings.warn(
                'The `warn_subclass` argument is deprecated as it is no longer necessary and will be removed in the next release',
                DeprecationWarning,
                stacklevel=3,
            )


    @staticmethod
    def create_partial(
        name: str,
        include: Optional[Iterable['types.RewardRedemptionKeys']] = None,
        exclude: Optional[Iterable['types.RewardRedemptionKeys']] = None,
        required: Optional[Iterable['types.RewardRedemptionKeys']] = None,
        optional: Optional[Iterable['types.RewardRedemptionKeys']] = None,
        relations: Optional[Mapping['types.RewardRedemptionRelationalFieldKeys', str]] = None,
        exclude_relational_fields: bool = False,
    ) -> None:
        if not os.environ.get('PRISMA_GENERATOR_INVOCATION'):
            raise RuntimeError(
                'Attempted to create a partial type outside of client generation.'
            )

        if name in _created_partial_types:
            raise ValueError(f'Partial type "{name}" has already been created.')

        if include is not None:
            if exclude is not None:
                raise TypeError('Exclude and include are mutually exclusive.')
            if exclude_relational_fields is True:
                raise TypeError('Include and exclude_relational_fields=True are mutually exclusive.')

        if required and optional:
            shared = set(required) & set(optional)
            if shared:
                raise ValueError(f'Cannot make the same field(s) required and optional {shared}')

        if exclude_relational_fields and relations:
            raise ValueError(
                'exclude_relational_fields and relations are mutually exclusive'
            )

        fields: Dict['types.RewardRedemptionKeys', PartialModelField] = OrderedDict()

        try:
            if include:
                for field in include:
                    fields[field] = _RewardRedemption_fields[field].copy()
            elif exclude:
                for field in exclude:
                    if field not in _RewardRedemption_fields:
                        raise KeyError(field)

                fields = {
                    key: data.copy()
                    for key, data in _RewardRedemption_fields.items()
                    if key not in exclude
                }
            else:
                fields = {
                    key: data.copy()
                    for key, data in _RewardRedemption_fields.items()
                }

            if required:
                for field in required:
                    fields[field]['optional'] = False

            if optional:
                for field in optional:
                    fields[field]['optional'] = True

            if exclude_relational_fields:
                fields = {
                    key: data
                    for key, data in fields.items()
                    if key not in _RewardRedemption_relational_fields
                }

            if relations:
                for field, type_ in relations.items():
                    if field not in _RewardRedemption_relational_fields:
                        raise errors.UnknownRelationalFieldError('RewardRedemption', field)

                    # TODO: this method of validating types is not ideal
                    # as it means we cannot two create partial types that
                    # reference each other
                    if type_ not in _created_partial_types:
                        raise ValueError(
                            f'Unknown partial type: "{type_}". '
                            f'Did you remember to generate the {type_} type before this one?'
                        )

                    # TODO: support non prisma.partials models
                    info = fields[field]
                    if info['is_list']:
                        info['type'] = f'List[\'partials.{type_}\']'
                    else:
                        info['type'] = f'\'partials.{type_}\''
        except KeyError as exc:
            raise ValueError(
                f'{exc.args[0]} is not a valid RewardRedemption / {name} field.'
            ) from None

        models = partial_models_ctx.get()
        models.append(
            {
                'name': name,
                'fields': cast(Mapping[str, PartialModelField], fields),
                'from_model': 'RewardRedemption',
            }
        )
        _created_partial_types.add(name)


class Achievement(bases.BaseAchievement):
    """Represents a Achievement record"""

    achievement_id: _int
    name: _str
    description: _str
    coin_bonus: _int
    condition_type: 'enums.ConditionType'
    condition_value: _int
    user_achievements: Optional[List['models.UserAchievement']] = None

    # take *args and **kwargs so that other metaclasses can define arguments
    def __init_subclass__(
        cls,
        *args: Any,
        warn_subclass: Optional[bool] = None,
        **kwargs: Any,
    ) -> None:
        super().__init_subclass__()
        if warn_subclass is not None:
            warnings.warn(
                'The `warn_subclass` argument is deprecated as it is no longer necessary and will be removed in the next release',
                DeprecationWarning,
                stacklevel=3,
            )


    @staticmethod
    def create_partial(
        name: str,
        include: Optional[Iterable['types.AchievementKeys']] = None,
        exclude: Optional[Iterable['types.AchievementKeys']] = None,
        required: Optional[Iterable['types.AchievementKeys']] = None,
        optional: Optional[Iterable['types.AchievementKeys']] = None,
        relations: Optional[Mapping['types.AchievementRelationalFieldKeys', str]] = None,
        exclude_relational_fields: bool = False,
    ) -> None:
        if not os.environ.get('PRISMA_GENERATOR_INVOCATION'):
            raise RuntimeError(
                'Attempted to create a partial type outside of client generation.'
            )

        if name in _created_partial_types:
            raise ValueError(f'Partial type "{name}" has already been created.')

        if include is not None:
            if exclude is not None:
                raise TypeError('Exclude and include are mutually exclusive.')
            if exclude_relational_fields is True:
                raise TypeError('Include and exclude_relational_fields=True are mutually exclusive.')

        if required and optional:
            shared = set(required) & set(optional)
            if shared:
                raise ValueError(f'Cannot make the same field(s) required and optional {shared}')

        if exclude_relational_fields and relations:
            raise ValueError(
                'exclude_relational_fields and relations are mutually exclusive'
            )

        fields: Dict['types.AchievementKeys', PartialModelField] = OrderedDict()

        try:
            if include:
                for field in include:
                    fields[field] = _Achievement_fields[field].copy()
            elif exclude:
                for field in exclude:
                    if field not in _Achievement_fields:
                        raise KeyError(field)

                fields = {
                    key: data.copy()
                    for key, data in _Achievement_fields.items()
                    if key not in exclude
                }
            else:
                fields = {
                    key: data.copy()
                    for key, data in _Achievement_fields.items()
                }

            if required:
                for field in required:
                    fields[field]['optional'] = False

            if optional:
                for field in optional:
                    fields[field]['optional'] = True

            if exclude_relational_fields:
                fields = {
                    key: data
                    for key, data in fields.items()
                    if key not in _Achievement_relational_fields
                }

            if relations:
                for field, type_ in relations.items():
                    if field not in _Achievement_relational_fields:
                        raise errors.UnknownRelationalFieldError('Achievement', field)

                    # TODO: this method of validating types is not ideal
                    # as it means we cannot two create partial types that
                    # reference each other
                    if type_ not in _created_partial_types:
                        raise ValueError(
                            f'Unknown partial type: "{type_}". '
                            f'Did you remember to generate the {type_} type before this one?'
                        )

                    # TODO: support non prisma.partials models
                    info = fields[field]
                    if info['is_list']:
                        info['type'] = f'List[\'partials.{type_}\']'
                    else:
                        info['type'] = f'\'partials.{type_}\''
        except KeyError as exc:
            raise ValueError(
                f'{exc.args[0]} is not a valid Achievement / {name} field.'
            ) from None

        models = partial_models_ctx.get()
        models.append(
            {
                'name': name,
                'fields': cast(Mapping[str, PartialModelField], fields),
                'from_model': 'Achievement',
            }
        )
        _created_partial_types.add(name)


class UserAchievement(bases.BaseUserAchievement):
    """Represents a UserAchievement record"""

    user: Optional['models.User'] = None
    user_id: _int
    achievement: Optional['models.Achievement'] = None
    achievement_id: _int
    unlocked_at: datetime.datetime

    # take *args and **kwargs so that other metaclasses can define arguments
    def __init_subclass__(
        cls,
        *args: Any,
        warn_subclass: Optional[bool] = None,
        **kwargs: Any,
    ) -> None:
        super().__init_subclass__()
        if warn_subclass is not None:
            warnings.warn(
                'The `warn_subclass` argument is deprecated as it is no longer necessary and will be removed in the next release',
                DeprecationWarning,
                stacklevel=3,
            )


    @staticmethod
    def create_partial(
        name: str,
        include: Optional[Iterable['types.UserAchievementKeys']] = None,
        exclude: Optional[Iterable['types.UserAchievementKeys']] = None,
        required: Optional[Iterable['types.UserAchievementKeys']] = None,
        optional: Optional[Iterable['types.UserAchievementKeys']] = None,
        relations: Optional[Mapping['types.UserAchievementRelationalFieldKeys', str]] = None,
        exclude_relational_fields: bool = False,
    ) -> None:
        if not os.environ.get('PRISMA_GENERATOR_INVOCATION'):
            raise RuntimeError(
                'Attempted to create a partial type outside of client generation.'
            )

        if name in _created_partial_types:
            raise ValueError(f'Partial type "{name}" has already been created.')

        if include is not None:
            if exclude is not None:
                raise TypeError('Exclude and include are mutually exclusive.')
            if exclude_relational_fields is True:
                raise TypeError('Include and exclude_relational_fields=True are mutually exclusive.')

        if required and optional:
            shared = set(required) & set(optional)
            if shared:
                raise ValueError(f'Cannot make the same field(s) required and optional {shared}')

        if exclude_relational_fields and relations:
            raise ValueError(
                'exclude_relational_fields and relations are mutually exclusive'
            )

        fields: Dict['types.UserAchievementKeys', PartialModelField] = OrderedDict()

        try:
            if include:
                for field in include:
                    fields[field] = _UserAchievement_fields[field].copy()
            elif exclude:
                for field in exclude:
                    if field not in _UserAchievement_fields:
                        raise KeyError(field)

                fields = {
                    key: data.copy()
                    for key, data in _UserAchievement_fields.items()
                    if key not in exclude
                }
            else:
                fields = {
                    key: data.copy()
                    for key, data in _UserAchievement_fields.items()
                }

            if required:
                for field in required:
                    fields[field]['optional'] = False

            if optional:
                for field in optional:
                    fields[field]['optional'] = True

            if exclude_relational_fields:
                fields = {
                    key: data
                    for key, data in fields.items()
                    if key not in _UserAchievement_relational_fields
                }

            if relations:
                for field, type_ in relations.items():
                    if field not in _UserAchievement_relational_fields:
                        raise errors.UnknownRelationalFieldError('UserAchievement', field)

                    # TODO: this method of validating types is not ideal
                    # as it means we cannot two create partial types that
                    # reference each other
                    if type_ not in _created_partial_types:
                        raise ValueError(
                            f'Unknown partial type: "{type_}". '
                            f'Did you remember to generate the {type_} type before this one?'
                        )

                    # TODO: support non prisma.partials models
                    info = fields[field]
                    if info['is_list']:
                        info['type'] = f'List[\'partials.{type_}\']'
                    else:
                        info['type'] = f'\'partials.{type_}\''
        except KeyError as exc:
            raise ValueError(
                f'{exc.args[0]} is not a valid UserAchievement / {name} field.'
            ) from None

        models = partial_models_ctx.get()
        models.append(
            {
                'name': name,
                'fields': cast(Mapping[str, PartialModelField], fields),
                'from_model': 'UserAchievement',
            }
        )
        _created_partial_types.add(name)



_User_relational_fields: Set[str] = {
        'todos',
        'Todo_categories',
        'coin_transactions',
        'reward_redemptions',
        'user_achievements',
    }
_User_fields: Dict['types.UserKeys', PartialModelField] = OrderedDict(
    [
        ('user_id', {
            'name': 'user_id',
            'is_list': False,
            'optional': False,
            'type': '_int',
            'is_relational': False,
            'documentation': None,
        }),
        ('username', {
            'name': 'username',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('email', {
            'name': 'email',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('password_hash', {
            'name': 'password_hash',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('total_coins', {
            'name': 'total_coins',
            'is_list': False,
            'optional': False,
            'type': '_int',
            'is_relational': False,
            'documentation': None,
        }),
        ('streak_count', {
            'name': 'streak_count',
            'is_list': False,
            'optional': False,
            'type': '_int',
            'is_relational': False,
            'documentation': None,
        }),
        ('last_active_date', {
            'name': 'last_active_date',
            'is_list': False,
            'optional': True,
            'type': 'datetime.datetime',
            'is_relational': False,
            'documentation': None,
        }),
        ('todos', {
            'name': 'todos',
            'is_list': True,
            'optional': True,
            'type': 'List[\'models.Todo\']',
            'is_relational': True,
            'documentation': None,
        }),
        ('Todo_categories', {
            'name': 'Todo_categories',
            'is_list': True,
            'optional': True,
            'type': 'List[\'models.TodoCategory\']',
            'is_relational': True,
            'documentation': None,
        }),
        ('coin_transactions', {
            'name': 'coin_transactions',
            'is_list': True,
            'optional': True,
            'type': 'List[\'models.CoinTransaction\']',
            'is_relational': True,
            'documentation': None,
        }),
        ('reward_redemptions', {
            'name': 'reward_redemptions',
            'is_list': True,
            'optional': True,
            'type': 'List[\'models.RewardRedemption\']',
            'is_relational': True,
            'documentation': None,
        }),
        ('user_achievements', {
            'name': 'user_achievements',
            'is_list': True,
            'optional': True,
            'type': 'List[\'models.UserAchievement\']',
            'is_relational': True,
            'documentation': None,
        }),
    ],
)

_TodoCategory_relational_fields: Set[str] = {
        'todos',
        'user',
    }
_TodoCategory_fields: Dict['types.TodoCategoryKeys', PartialModelField] = OrderedDict(
    [
        ('category_id', {
            'name': 'category_id',
            'is_list': False,
            'optional': False,
            'type': '_int',
            'is_relational': False,
            'documentation': None,
        }),
        ('category_name', {
            'name': 'category_name',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('difficulty_multiplier', {
            'name': 'difficulty_multiplier',
            'is_list': False,
            'optional': False,
            'type': '_float',
            'is_relational': False,
            'documentation': None,
        }),
        ('todos', {
            'name': 'todos',
            'is_list': True,
            'optional': True,
            'type': 'List[\'models.Todo\']',
            'is_relational': True,
            'documentation': None,
        }),
        ('user', {
            'name': 'user',
            'is_list': False,
            'optional': True,
            'type': 'models.User',
            'is_relational': True,
            'documentation': None,
        }),
        ('user_id', {
            'name': 'user_id',
            'is_list': False,
            'optional': False,
            'type': '_int',
            'is_relational': False,
            'documentation': None,
        }),
    ],
)

_Todo_relational_fields: Set[str] = {
        'user',
        'category',
        'coin_transactions',
    }
_Todo_fields: Dict['types.TodoKeys', PartialModelField] = OrderedDict(
    [
        ('todo_id', {
            'name': 'todo_id',
            'is_list': False,
            'optional': False,
            'type': '_int',
            'is_relational': False,
            'documentation': None,
        }),
        ('user', {
            'name': 'user',
            'is_list': False,
            'optional': True,
            'type': 'models.User',
            'is_relational': True,
            'documentation': None,
        }),
        ('user_id', {
            'name': 'user_id',
            'is_list': False,
            'optional': False,
            'type': '_int',
            'is_relational': False,
            'documentation': None,
        }),
        ('title', {
            'name': 'title',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('description', {
            'name': 'description',
            'is_list': False,
            'optional': True,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('due_date', {
            'name': 'due_date',
            'is_list': False,
            'optional': True,
            'type': 'datetime.datetime',
            'is_relational': False,
            'documentation': None,
        }),
        ('base_coin_value', {
            'name': 'base_coin_value',
            'is_list': False,
            'optional': False,
            'type': '_int',
            'is_relational': False,
            'documentation': None,
        }),
        ('completed', {
            'name': 'completed',
            'is_list': False,
            'optional': False,
            'type': '_bool',
            'is_relational': False,
            'documentation': None,
        }),
        ('completion_date', {
            'name': 'completion_date',
            'is_list': False,
            'optional': True,
            'type': 'datetime.datetime',
            'is_relational': False,
            'documentation': None,
        }),
        ('category', {
            'name': 'category',
            'is_list': False,
            'optional': True,
            'type': 'models.TodoCategory',
            'is_relational': True,
            'documentation': None,
        }),
        ('category_id', {
            'name': 'category_id',
            'is_list': False,
            'optional': True,
            'type': '_int',
            'is_relational': False,
            'documentation': None,
        }),
        ('coin_transactions', {
            'name': 'coin_transactions',
            'is_list': True,
            'optional': True,
            'type': 'List[\'models.CoinTransaction\']',
            'is_relational': True,
            'documentation': None,
        }),
    ],
)

_CoinTransaction_relational_fields: Set[str] = {
        'user',
        'related_todo',
    }
_CoinTransaction_fields: Dict['types.CoinTransactionKeys', PartialModelField] = OrderedDict(
    [
        ('transaction_id', {
            'name': 'transaction_id',
            'is_list': False,
            'optional': False,
            'type': '_int',
            'is_relational': False,
            'documentation': None,
        }),
        ('user', {
            'name': 'user',
            'is_list': False,
            'optional': True,
            'type': 'models.User',
            'is_relational': True,
            'documentation': None,
        }),
        ('user_id', {
            'name': 'user_id',
            'is_list': False,
            'optional': False,
            'type': '_int',
            'is_relational': False,
            'documentation': None,
        }),
        ('amount', {
            'name': 'amount',
            'is_list': False,
            'optional': False,
            'type': '_int',
            'is_relational': False,
            'documentation': None,
        }),
        ('transaction_type', {
            'name': 'transaction_type',
            'is_list': False,
            'optional': False,
            'type': 'enums.TransactionType',
            'is_relational': False,
            'documentation': None,
        }),
        ('transaction_time', {
            'name': 'transaction_time',
            'is_list': False,
            'optional': False,
            'type': 'datetime.datetime',
            'is_relational': False,
            'documentation': None,
        }),
        ('related_todo', {
            'name': 'related_todo',
            'is_list': False,
            'optional': True,
            'type': 'models.Todo',
            'is_relational': True,
            'documentation': None,
        }),
        ('related_todo_id', {
            'name': 'related_todo_id',
            'is_list': False,
            'optional': True,
            'type': '_int',
            'is_relational': False,
            'documentation': None,
        }),
    ],
)

_Reward_relational_fields: Set[str] = {
        'reward_redemptions',
    }
_Reward_fields: Dict['types.RewardKeys', PartialModelField] = OrderedDict(
    [
        ('reward_id', {
            'name': 'reward_id',
            'is_list': False,
            'optional': False,
            'type': '_int',
            'is_relational': False,
            'documentation': None,
        }),
        ('reward_name', {
            'name': 'reward_name',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('description', {
            'name': 'description',
            'is_list': False,
            'optional': True,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('coin_cost', {
            'name': 'coin_cost',
            'is_list': False,
            'optional': False,
            'type': '_int',
            'is_relational': False,
            'documentation': None,
        }),
        ('is_repeatable', {
            'name': 'is_repeatable',
            'is_list': False,
            'optional': False,
            'type': '_bool',
            'is_relational': False,
            'documentation': None,
        }),
        ('reward_redemptions', {
            'name': 'reward_redemptions',
            'is_list': True,
            'optional': True,
            'type': 'List[\'models.RewardRedemption\']',
            'is_relational': True,
            'documentation': None,
        }),
    ],
)

_RewardRedemption_relational_fields: Set[str] = {
        'user',
        'reward',
    }
_RewardRedemption_fields: Dict['types.RewardRedemptionKeys', PartialModelField] = OrderedDict(
    [
        ('redemption_id', {
            'name': 'redemption_id',
            'is_list': False,
            'optional': False,
            'type': '_int',
            'is_relational': False,
            'documentation': None,
        }),
        ('user', {
            'name': 'user',
            'is_list': False,
            'optional': True,
            'type': 'models.User',
            'is_relational': True,
            'documentation': None,
        }),
        ('user_id', {
            'name': 'user_id',
            'is_list': False,
            'optional': False,
            'type': '_int',
            'is_relational': False,
            'documentation': None,
        }),
        ('reward', {
            'name': 'reward',
            'is_list': False,
            'optional': True,
            'type': 'models.Reward',
            'is_relational': True,
            'documentation': None,
        }),
        ('reward_id', {
            'name': 'reward_id',
            'is_list': False,
            'optional': False,
            'type': '_int',
            'is_relational': False,
            'documentation': None,
        }),
        ('redemption_date', {
            'name': 'redemption_date',
            'is_list': False,
            'optional': False,
            'type': 'datetime.datetime',
            'is_relational': False,
            'documentation': None,
        }),
    ],
)

_Achievement_relational_fields: Set[str] = {
        'user_achievements',
    }
_Achievement_fields: Dict['types.AchievementKeys', PartialModelField] = OrderedDict(
    [
        ('achievement_id', {
            'name': 'achievement_id',
            'is_list': False,
            'optional': False,
            'type': '_int',
            'is_relational': False,
            'documentation': None,
        }),
        ('name', {
            'name': 'name',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('description', {
            'name': 'description',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('coin_bonus', {
            'name': 'coin_bonus',
            'is_list': False,
            'optional': False,
            'type': '_int',
            'is_relational': False,
            'documentation': None,
        }),
        ('condition_type', {
            'name': 'condition_type',
            'is_list': False,
            'optional': False,
            'type': 'enums.ConditionType',
            'is_relational': False,
            'documentation': None,
        }),
        ('condition_value', {
            'name': 'condition_value',
            'is_list': False,
            'optional': False,
            'type': '_int',
            'is_relational': False,
            'documentation': None,
        }),
        ('user_achievements', {
            'name': 'user_achievements',
            'is_list': True,
            'optional': True,
            'type': 'List[\'models.UserAchievement\']',
            'is_relational': True,
            'documentation': None,
        }),
    ],
)

_UserAchievement_relational_fields: Set[str] = {
        'user',
        'achievement',
    }
_UserAchievement_fields: Dict['types.UserAchievementKeys', PartialModelField] = OrderedDict(
    [
        ('user', {
            'name': 'user',
            'is_list': False,
            'optional': True,
            'type': 'models.User',
            'is_relational': True,
            'documentation': None,
        }),
        ('user_id', {
            'name': 'user_id',
            'is_list': False,
            'optional': False,
            'type': '_int',
            'is_relational': False,
            'documentation': None,
        }),
        ('achievement', {
            'name': 'achievement',
            'is_list': False,
            'optional': True,
            'type': 'models.Achievement',
            'is_relational': True,
            'documentation': None,
        }),
        ('achievement_id', {
            'name': 'achievement_id',
            'is_list': False,
            'optional': False,
            'type': '_int',
            'is_relational': False,
            'documentation': None,
        }),
        ('unlocked_at', {
            'name': 'unlocked_at',
            'is_list': False,
            'optional': False,
            'type': 'datetime.datetime',
            'is_relational': False,
            'documentation': None,
        }),
    ],
)



# we have to import ourselves as relation types are namespaced to models
# e.g. models.Post
from . import models, actions

# required to support relationships between models
model_rebuild(User)
model_rebuild(TodoCategory)
model_rebuild(Todo)
model_rebuild(CoinTransaction)
model_rebuild(Reward)
model_rebuild(RewardRedemption)
model_rebuild(Achievement)
model_rebuild(UserAchievement)
